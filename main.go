package main

import (
	"bufio"
	"bytes"
	"context"
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/chromedp/cdproto/cdp"
	"github.com/chromedp/chromedp"
	"github.com/joho/godotenv"
)

// !!! –ù–û–í–û–ï: –°–ø–∏—Å–æ–∫ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ –¥–ª—è –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏—è CAPTCHA –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —Å–∞–π—Ç–∞—Ö !!!
var captchaKeywords = []string{
	// –†—É—Å—Å–∫–∏–µ
	"–∫–∞–ø—á–∞",
	"–Ω–µ —Ä–æ–±–æ—Ç",
	"–ø–æ–¥–æ–∑—Ä–∏—Ç–µ–ª—å–Ω–∞—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å",
	"–ø–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ, —á—Ç–æ",

	// –ê–Ω–≥–ª–∏–π—Å–∫–∏–µ
	"unusual traffic",
	"are you a robot",
	"prove you are human",
	"captcha",
}

// --- –ì–ª–æ–±–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è CAPTCHA ---
var (
	persistentBrowserCtx context.Context
	isCaptchaPending     bool
	captchaMutex         sync.Mutex
)

// ... (—Å—Ç—Ä—É–∫—Ç—É—Ä—ã Link, Meta, Response –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
type Link struct {
	Href string `json:"href"`
	Text string `json:"text"`
}
type Meta struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Keywords    string `json:"keywords"`
}
type Response struct {
	Content string `json:"content,omitempty"`
	Links   []Link `json:"links,omitempty"`
	Meta    *Meta  `json:"meta,omitempty"`
}

// ... (sendTelegramNotification –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
func sendTelegramNotification(message string) {
	botToken := os.Getenv("TELEGRAM_BOT_TOKEN")
	chatID := os.Getenv("TELEGRAM_CHAT_ID")
	if botToken == "" || chatID == "" {
		log.Println("–õ–û–ì: –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ TELEGRAM –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø—Ä–æ–ø—É—â–µ–Ω–æ.")
		return
	}
	apiURL := fmt.Sprintf("https://api.telegram.org/bot%s/sendMessage", botToken)
	requestBody, _ := json.Marshal(map[string]string{"chat_id": chatID, "text": message})
	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Post(apiURL, "application/json", bytes.NewBuffer(requestBody))
	if err != nil {
		log.Printf("–õ–û–ì: –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –≤ Telegram: %v", err)
		return
	}
	defer resp.Body.Close()
	if resp.StatusCode == http.StatusOK {
		log.Println("–õ–û–ì: –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ Telegram —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ.")
	} else {
		log.Printf("–õ–û–ì: Telegram API –≤–µ—Ä–Ω—É–ª –æ—à–∏–±–∫—É: %s", resp.Status)
	}
}

// detectAndPauseOnCaptcha - —Ç–µ–ø–µ—Ä—å –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ —Å–ø–∏—Å–∫—É –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤.
func detectAndPauseOnCaptcha(url string) chromedp.Action {
	return chromedp.ActionFunc(func(ctx context.Context) error {
		log.Println("–õ–û–ì: –®–∞–≥ [1] - –ü—Ä–æ–≤–µ—Ä—è—é –Ω–∞–ª–∏—á–∏–µ CAPTCHA –Ω–∞ —Å—Ç—Ä–∞–Ω–∏—Ü–µ.")
		var bodyText string
		if err := chromedp.Text(`body`, &bodyText, chromedp.ByQuery).Do(ctx); err != nil {
			return err
		}

		// –ü—Ä–∏–≤–æ–¥–∏–º —Ç–µ–∫—Å—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã –∫ –Ω–∏–∂–Ω–µ–º—É —Ä–µ–≥–∏—Å—Ç—Ä—É –¥–ª—è –Ω–∞–¥–µ–∂–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞
		lowerBodyText := strings.ToLower(bodyText)

		// !!! –ò–ó–ú–ï–ù–ï–ù–ù–ê–Ø –õ–û–ì–ò–ö–ê: –ò—â–µ–º –ª—é–±–æ–µ –∏–∑ –∫–ª—é—á–µ–≤—ã—Ö —Å–ª–æ–≤ !!!
		for _, keyword := range captchaKeywords {
			if strings.Contains(lowerBodyText, keyword) {
				// –ù–∞—à–ª–∏! –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ü–µ–¥—É—Ä—É –æ–∂–∏–¥–∞–Ω–∏—è.
				captchaMutex.Lock()
				isCaptchaPending = true
				captchaMutex.Unlock()

				message := fmt.Sprintf("üö® –û–ë–ù–ê–†–£–ñ–ï–ù–ê CAPTCHA! (–ù–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤–æ: '%s') üö®\n\nURL: %s\n\n–î–µ–π—Å—Ç–≤–∏–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, —Ä–µ—à–∏—Ç–µ –∫–∞–ø—á—É –∏ –Ω–∞–∂–º–∏—Ç–µ Enter –≤ —ç—Ç–æ–π –∫–æ–Ω—Å–æ–ª–∏.", keyword, url)
				go sendTelegramNotification(message)

				log.Println("\n======================================================================")
				log.Println(message)
				log.Println("======================================================================")

				for {
					captchaMutex.Lock()
					if !isCaptchaPending {
						captchaMutex.Unlock()
						break
					}
					captchaMutex.Unlock()
					time.Sleep(1 * time.Second)
				}

				log.Println("–õ–û–ì: Enter –Ω–∞–∂–∞—Ç, –ø—Ä–æ–¥–æ–ª–∂–∞—é –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ...")
				return chromedp.Sleep(2 * time.Second).Do(ctx)
			}
		}

		log.Println("–õ–û–ì: –®–∞–≥ [1] - CAPTCHA –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞, –ø—Ä–æ–¥–æ–ª–∂–∞—é.")
		return nil
	})
}

func scrapeHandler(w http.ResponseWriter, r *http.Request) {
	log.Printf("\n–õ–û–ì: –ü–æ–ª—É—á–µ–Ω –Ω–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å: %s", r.URL.String())

	captchaMutex.Lock()
	if isCaptchaPending {
		captchaMutex.Unlock()
		log.Println("–õ–û–ì: –û—Ç–∫–ª–æ–Ω—è—é –∑–∞–ø—Ä–æ—Å, —Ç–∞–∫ –∫–∞–∫ —É–∂–µ —Ä–µ—à–∞–µ—Ç—Å—è CAPTCHA.")
		http.Error(w, "–°–µ—Ä–≤–∏—Å –∑–∞–Ω—è—Ç —Ä–µ—à–µ–Ω–∏–µ–º CAPTCHA. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.", http.StatusServiceUnavailable)
		return
	}
	captchaMutex.Unlock()

	url := r.URL.Query().Get("url")
	if url == "" {
		http.Error(w, "–ü–∞—Ä–∞–º–µ—Ç—Ä 'url' –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω", http.StatusBadRequest)
		return
	}

	tabCtx, cancelTab := chromedp.NewContext(persistentBrowserCtx)
	defer func() {
		log.Println("–õ–û–ì: –®–∞–≥ [4] - –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∑–∞–≤–µ—Ä—à–µ–Ω, –∑–∞–∫—Ä—ã–≤–∞—é –≤–∫–ª–∞–¥–∫—É.")
		cancelTab()
	}()

	var response Response

	log.Println("–õ–û–ì: –®–∞–≥ [0] - –ù–∞—á–∏–Ω–∞—é –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∑–∞–¥–∞—á –≤ –Ω–æ–≤–æ–π –≤–∫–ª–∞–¥–∫–µ.")
	err := chromedp.Run(tabCtx,
		chromedp.Navigate(url),
		chromedp.WaitVisible(`body`, chromedp.ByQuery),
		detectAndPauseOnCaptcha(url),
		chromedp.ActionFunc(func(c context.Context) error {
			log.Println("–õ–û–ì: –®–∞–≥ [2] - –°–æ–±–∏—Ä–∞—é –¥–∞–Ω–Ω—ã–µ —Å–æ —Å—Ç—Ä–∞–Ω–∏—Ü—ã.")
			// --- –ü–æ–ª–Ω–∞—è –ª–æ–≥–∏–∫–∞ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö ---
			if r.URL.Query().Has("content") {
				var content string
				if err := chromedp.Text(`body`, &content, chromedp.ByQuery).Do(c); err != nil {
					return err
				}
				response.Content = strings.TrimSpace(content)
			}
			if r.URL.Query().Has("links") {
				var nodes []*cdp.Node
				if err := chromedp.Nodes("a", &nodes, chromedp.ByQueryAll).Do(c); err != nil {
					return err
				}
				for _, node := range nodes {
					href := node.AttributeValue("href")
					if href == "" || strings.HasPrefix(href, "#") {
						continue
					}
					var text string
					// –ò—Å–ø–æ–ª—å–∑—É–µ–º Do(c), —á—Ç–æ–±—ã –≤—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ–π—Å—Ç–≤–∏–µ –≤ —Ç–µ–∫—É—â–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ –≤–∫–ª–∞–¥–∫–∏
					_ = chromedp.Text(node.FullXPath(), &text, chromedp.BySearch).Do(c)
					response.Links = append(response.Links, Link{
						Href: href,
						Text: strings.TrimSpace(text),
					})
				}
			}
			if r.URL.Query().Has("meta") {
				var meta Meta
				_ = chromedp.Title(&meta.Title).Do(c)
				_ = chromedp.AttributeValue(`meta[name="description"]`, "content", &meta.Description, nil, chromedp.ByQuery).Do(c)
				_ = chromedp.AttributeValue(`meta[name="keywords"]`, "content", &meta.Keywords, nil, chromedp.ByQuery).Do(c)
				response.Meta = &meta
			}
			// --- –ö–æ–Ω–µ—Ü –ª–æ–≥–∏–∫–∏ —Å–±–æ—Ä–∞ –¥–∞–Ω–Ω—ã—Ö ---
			log.Println("–õ–û–ì: –®–∞–≥ [3] - –°–±–æ—Ä –¥–∞–Ω–Ω—ã—Ö –∑–∞–≤–µ—Ä—à–µ–Ω.")
			return nil
		}),
	)

	if err != nil {
		log.Printf("–õ–û–ì: –û—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è chromedp: %v", err)
		http.Error(w, "–ù–µ —É–¥–∞–ª–æ—Å—å –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Å–∫—Ä–∞–ø–∏–Ω–≥: "+err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	json.NewEncoder(w).Encode(response)
}

// ... (manageConsoleInput –∏ main –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
func manageConsoleInput() {
	reader := bufio.NewReader(os.Stdin)
	for {
		reader.ReadString('\n')
		captchaMutex.Lock()
		if isCaptchaPending {
			isCaptchaPending = false
			log.Println("–õ–û–ì: –ö–æ–Ω—Å–æ–ª—å: –ø–æ–ª—É—á–µ–Ω Enter, —Ñ–ª–∞–≥ CAPTCHA —Å–Ω—è—Ç.")
		}
		captchaMutex.Unlock()
	}
}

func main() {
	_ = godotenv.Load()
	headless := flag.Bool("headless", false, "–ó–∞–ø—É—Å–∫ –±—Ä–∞—É–∑–µ—Ä–∞ –≤ headless —Ä–µ–∂–∏–º–µ")
	flag.Parse()

	if *headless {
		log.Fatal("–ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: –≠—Ç–æ—Ç —Ä–µ–∂–∏–º —Ç—Ä–µ–±—É–µ—Ç —Ä—É—á–Ω–æ–≥–æ –≤–≤–æ–¥–∞ –∏ –Ω–µ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å —Ñ–ª–∞–≥–æ–º -headless=true")
	}

	go manageConsoleInput()

	opts := append(chromedp.DefaultExecAllocatorOptions[:],
		chromedp.Flag("headless", *headless),
		chromedp.UserAgent(`Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/117.0.0.0 Safari/537.36`),
		chromedp.Flag("disable-blink-features", "AutomationControlled"),
		chromedp.NoSandbox,
		chromedp.DisableGPU,
	)

	allocCtx, cancelAlloc := chromedp.NewExecAllocator(context.Background(), opts...)
	defer cancelAlloc()

	var cancelBrowser func()
	persistentBrowserCtx, cancelBrowser = chromedp.NewContext(allocCtx, chromedp.WithLogf(log.Printf))
	defer cancelBrowser()

	if err := chromedp.Run(persistentBrowserCtx); err != nil {
		log.Fatalf("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –±—Ä–∞—É–∑–µ—Ä: %v", err)
	}
	log.Println("–õ–û–ì: –ü–æ—Å—Ç–æ—è–Ω–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±—Ä–∞—É–∑–µ—Ä–∞ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω.")

	http.HandleFunc("/scrape", scrapeHandler)

	port := os.Getenv("PORT")
	if port == "" {
		port = "8080"
	}
	addr := ":" + port
	log.Printf("–°–µ—Ä–≤–µ—Ä –∑–∞–ø—É—â–µ–Ω –Ω–∞ http://localhost%s", addr)
	log.Println("–†–µ–∂–∏–º: —Å –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º (non-headless)")
	log.Fatal(http.ListenAndServe(addr, nil))
}
